use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use validator::Validate;

/// Login payload shape.
///
/// Notes for future AI-driven refactors:
/// - Validation is handled by actix-web-validator on extraction, thanks to `Validate` derives.
/// - Password is included here because typical login requires it; however, at the moment we do not verify it.
#[derive(Debug, Deserialize, Validate)]
pub struct LoginUserSchema {
    /// Email address of the user attempting to log in.
    #[validate(length(min = 4, max = 250, message = "Email must be between 4 to 250"))]
    #[validate(email(code = "code_str", message = "Invalid email address"))]
    pub email: String,
    /// Plain text password provided by the user.
    /// Currently unused for verification, but kept for forward compatibility.
    #[validate(length(min = 6, message = "Password must be greater than 8 characters"))]
    pub password: String,
}


/// UserModel registration payload shape.
///
/// Notes for future AI-driven refactors:
/// - Validation is handled by actix-web-validator on extraction via the `Validate` derive.
/// - All fields are required and have length/format validations.
/// - First name and last name must be between 1-100 characters.
/// - Email must be valid format and between 4-250 characters.
/// - Password must be at least 6 characters.
#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserSchema {
    /// UserModel's first name, must be between 1-100 characters
    #[validate(length(min = 1, max = 100, message = "First name must be between 1 to 100"))]
    pub first_name: String,
    /// UserModel's last name, must be between 1-100 characters
    #[validate(length(min = 1, max = 100, message = "Last name must be between 1 to 100"))]
    pub last_name: String,
    /// Valid email address, must be between 4-250 characters
    #[validate(length(min = 4, max = 250, message = "Email must be between 4 to 250"))]
    #[validate(email(code = "code_str", message = "Invalid email address"))]
    pub email: String,
    /// Password in plain text, must be at least 6 characters
    #[validate(length(min = 6, message = "Password must be greater than 6 characters"))]
    pub password: Option<String>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct UpdateProfileSchema {
    #[validate(length(min = 1, max = 100, message = "First name must be between 1 to 100"))]
    pub first_name: String,
    #[validate(length(min = 1, max = 100, message = "Last name must be between 1 to 100"))]
    pub last_name: String,
    #[validate(length(min = 4, max = 250, message = "Email must be between 4 to 250"))]
    #[validate(email(code = "code_str", message = "Invalid email address"))]
    pub email: String,
    pub password: Option<String>,
}

/// UserModel domain model reflecting the `users` table.
///
/// This struct is used for fetching rows via SQLx and serializing back to clients.
/// Sensitive fields like `password` are marked with `skip_serializing` to avoid leaking secrets.
///
/// Columns are aligned with the migration in `src/migrations/20251016175919_create_users_table.up.sql`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserModel {
    /// Primary key (generated by Postgres uuid_generate_v4())
    pub id: Uuid,
    pub first_name: String,
    pub last_name: String,
    pub email: String,
    pub phone: Option<String>,
    /// Password hash. Never serialize this field in API responses.
    #[serde(skip_serializing)]
    pub password: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password_reset_token: Option<String>,
    pub is_superuser: bool,
    #[serde(skip_serializing)]
    pub verification_token: Option<Uuid>,
    pub last_logged_in_at: Option<DateTime<Utc>>,
    pub current_logged_in_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deleted_at: Option<DateTime<Utc>>,
}